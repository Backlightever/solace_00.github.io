<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script> 

#1.什么是个体学习器？
个体学习器是由一个现有的学习算法从训练数据中产生的分类器.如：C4.5决策树算法、BP神经网络算法等.
#2.什么是集成学习？
##集成学习的概念
通过构建并结合多个学习器来实现学习任务, 又称为multi_classifer system, committee_based learning. 集成学习的一般结构: 先产生一组"个体学习器", 再用某种策略将他们结合起来. 示意图如下:
##集成学习的分类
###根据个体学习的类型
+	同质集成
+	异质集成
###根据个体学习器的生成方式
+	串行生成的序列化方法: Boosting
+	并行化方法: Bagging, Random Forest
#3.Boosting和Bagging
##Boosting
Boosting 是一族可以将弱学习器提升为强学习器的算法, 其工作机制类似: 先从初始训练集训练出一个基学习器, 在根据基学习器的表现对训练样本分布进行调整, 使得先前基学习器做错的训练样本在后续受到更多的关注, 然后基于调整后的样本分布来训练下一个基学习器, 如此重复进行, 直至基学习器数目达到事先指定的值T, 最终将这T个基学习器进行加权结合. 
##Bagging
Bagging是并行式集成学习方法. 工作机制如下: 给定包含m个样本的数据集, 我们先随机取出一个样本放入采样集中, 这样, 经过m次随机采样操作, 我们得到含m个样本的采样集, 如此可以得到T个含m个训练样本的采样集, 在基于每个采样集训练出一个基学习器, 再将这些基学习器结合.
#4.结合策略
##why为什么要将学习器结合？

（1）从统计方面来看, 由于学习任务的假设空间往往很大, 可能有多个假设在训练集上达到同等性能, 使用单分类器泛化性能可能不佳, 结合多个分类器可以降低这一风险, 提高泛化能力;  

（2）从计算方面来看, 学习算法往往会陷入局部极小, 多个分类器结合, 可以降低陷入局部极小值的风险; 

（3）从表示方面来看, 采用多个学习器结合, 可以将学习任务的假设空间扩大, 可以改善真是假设不在单学习器假设空间的问题.
##几种常见的结合策略
###平均法: 
+	简单平均法
+	加权平均法
###投票法
+	绝对多数投票法: 即某类的票超过半数, 则预测为该类, 否则拒绝预测.
+	相对多数投票法: 即预测为的票最多的标记, 若同时有多个标记获最高票, 则从中随机抽取一个.
+	加权投票法: 对每个类赋予权重w, 与加权平均类似.
###学习法
当训练数据过多时, 可以采用“学习法”学习, 即通过另一个学习器来进行结合, 称作次级学习器或元学习器（meta-learning）. 
#5.随机森林思想
随机森林（Random Forest, 简称RF）是Bagging的一个扩展变体. RF在以决策树为基学习器构建Bagging集成的基础上, 进一步在决策树的训练过程中引入了随机属性选择. 具体来说, 传统决策树在选择划分属性时是在对当前结点的属性集合中选择一个最优属性; 而在RF中, 对基决策树的每个结点, 先从该结点的属性集合中随机选择一个包含k个属性的子集, 然后再从这个子集中选择一个最优属性用于划分. 这里的参数k控制了随机性的引入程度. 一般推荐值k=log2d(d为特征总数). 随机森林简单、容易实现、计算开销小, 而且性能强大. 
#6.随机森林的推广
由于RF在实际应用中效果良好, 因此产生了很多变种算法. 这些算法不仅可以应用于分类和回归, 还可以用于特征转换, 异常点检测等. 下面主要对Extra Trees, Totally Random Trees Embedding和Isolation Forest进行简单的介绍.
##6.1Extra Trees
Extra Trees是RF的一个变种, 原理与RF相同, 主要区别在于: 

1.Extra Trees不采用随机采样, 直接使用原始训练集作为决策树的训练集; 而RF采用的是随机采样bootstrap来选择采样集作为每个决策树的训练集; 

2.Extra Trees在选择划分特征后, 随机选择一个特征值来划分决策树; RF则与传统决策树划分方法相同（基于基尼指数、均方误差等原则）

从两者的区别可以看出, Extra Trees对特征值的划分并没有选取最优划分, 而是采用随机选取, 相较于RF而言比较极端, 在某些时候, extra trees的泛化能力要比RF好.
##6.2Totally Random Trees Embedding
Totally Random Trees Embedding(以下简称TRTE)是一种非监督学习的数据转化方法. 它将低维的数据集映射到高维, 从而让映射到高维的数据更好的运用于分类回归模型.TRTE算法主要进行了两部分操作，第一部分是对数据进行操作，第二部分是对生成的决策树的位置信息转换成向量信息以供之后构建特征编码使用。抛开数据集上的操作，TRTE算法对RF的变种在于如何参考最终生成的多个决策树来给出预测结果。RF采用投票的方式, 而TRTE算法中, 每个决策树会生成一个编码来对应叶子结点的位置信息, 那么把所有的决策树对应相同的分类编码合并起来, 就可以用这一合并后的编码来代表它的特征了, 预测时待预测样本经过这些决策树的预测也会得到这样一个合并后的编码，通过同训练好的类别的编码之间的差距的大小来预测这个样本应该属于哪一个类别。
##6.3Isolation Forest
Isolation Forest是用来异常点检测的, 它和RF算法的区别在于:

1.在随机采样过程中, 一般只需少量数据即可; 

2.在进行决策树构建过程中, IForest算法会随机选择一个划分特征, 并对划分特征随机选择一个划分阈值; 

3.Iforest算法构建的决策树一般最大深度是比较小的

###算法思路如下：
将测试样本x拟合到T棵决策树上, 计算在每棵树上该样本的叶子结点的深度, 得到平均深度. 深度越小说明样本x为异常点的概率越大.深度越大，表示样本点非异常点的概率越大.
#7.随机森林的优缺点
##随机森林的优点：
+	可以处理高维数据, 且不用做特征选择
+	训练速度快, 可以并行化 （树与树之间是相互独立的）
+	采用随机采样, 训练出的模型的方差小, 泛化能力强
+	对部分缺失值、异常值不敏感
+	训练后, 可以得到各个特征对于输出的重要性
+	相比于其他算法, 实现简单

##随机森林的缺点：
+ 当数据噪声过大时, 会产生过拟合现象
+ 取值划分较多的特征容易对RF的决策产生更大的影响, 影响模型的泛化效果
#8.sklearn
##sklearn中随机森林类参数
>class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion='gini', max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=1, random_state=None, verbose=0, warm_start=False, class_weight=None)
##参数
n_estimators : integer, optional (default=10)
>决策树的数目


criterion : string, optional (default=”gini”)
>The function to measure the quality of a split. Supported criteria are “gini” for the Gini impurity and “entropy” for the information gain. Note: this parameter is tree-specific.

max_features : int, float, string or None, optional (default=”auto”)


max_depth : integer or None, optional (default=None)
>决策树的最大深度

min_samples_split : int, float, optional (default=2) 
>分割内部节点所需要的最小样本数量

min_samples_leaf : int, float, optional (default=1) 
>需要在叶子结点上的最小样本数量

min_weight_fraction_leaf : float, optional (default=0.)  
>一个叶子节点所需要的权重总和（所有的输入样本）的最小加权分数

max_leaf_nodes : int or None, optional (default=None) 
>以最优的方法使用max_leaf_nodes来生长树

min_impurity_split : float
>树早期生长的阈值

min_impurity_decrease : float, optional (default=0.) 
>如果节点的分裂导致的impurity的下降程度大于或者等于这个节点的值，那么这个节点将会被分裂

bootstrap : boolean, optional (default=True) 
>建立决策树时，是否使用有放回抽样

oob_score : bool (default=False)  bool
>是否使用袋外样本来估计泛化精度

random_state : int, RandomState instance or None, optional (default=None) 
>随机数生成器使用的种子

verbose : int, optional (default=0)
>控制决策树建立过程的冗余度

n_jobs : integer, optional (default=1)
>并行工作的个数

class_weight : dict, list of dicts, “balanced”
>各个label的权重
#9.应用场景
+ 处理高维数据上有明显优势
+ 算法容易实现, 适合大规模数据 

